# KMP 算法说明

#证明过程
已知

源串          S S1 S2 ... Si Si+1 ... Si+j-1 Si+j ...
匹配串                    p0 p1   ... pj-1   pj

若
    Si Si+1 ... Si+j != p0 p1 ... pj-1 pj  且  Si Si+1 ... Si+j-1 == p0 p1 ... pj-1 
若存在 ( 最长首尾串定义 )
    P0 P1 ... Pk != pj-k-1 Pj-k ... Pj 且 P0 P1 ... Pk-1 == pj-k-1 Pj-k ... Pj-1 

则可以得出如下结论:
    当前匹配串下标为 j, 则仅需将匹配穿下标 左移 j-k 位，匹配 Pk 与 Si+j，若相等则往后匹配，若不等则再次查找首尾串进行移位匹配即可。

解：
                 
    P0 P1 ... Pk-1 == pj-k-1   Pj-k   ... Pj-1 
                   == P0       P1     ... Pk-1 
                   == Si+j-k-1 Si+j-k ... Si+j-1 

    已知 Pj != Si+j 故存在 Pk == Si+j 或 Pk != Si+j 两种情况
    既 匹配串 下标左移 j-k 为，对 Pk 进行匹配，若匹配OK，在匹配串与源串下标右移继续匹配，若不匹配则与命题条件一致，问题进行递归处理

综上：
    KMP算法 为 匹配串 每个首串的 最长首尾串的特征向量问题，使用该特征，进行特征匹配，减少无效匹配次数，有 O(n*m) 降低为 O(n+m)

# 最长首尾串说明 ( 真子串 )

  如 abcd  特征值 为 0 
  首串 a ab abc 
  尾串 d cd cbd

  如 abab    特征值 为 2
  首串 a ab aba
  尾串 b ab bab

  abab 特征数组 [0,0,1,2]
   
